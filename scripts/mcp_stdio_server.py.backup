#!/usr/bin/env python3
"""
Women's Health MCP Server - FastMCP Implementation
Provides clinical calculator and research tools via Model Context Protocol over stdio
"""

import asyncio
import sys
from pathlib import Path
from typing import Optional

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from fastmcp import FastMCP
import json

# Import research server modules
sys.path.insert(0, str(Path(__file__).parent.parent / "servers"))
from servers import pubmed_server, eshre_server, nams_server, elsa_server, sart_ivf_server, asrm_server

# Create FastMCP server
mcp = FastMCP("women-health-mcp")


# ==================== Clinical Calculator Tools ====================

@mcp.tool()
async def predict_ivf_success(
    age: int,
    amh: float,
    height_cm: Optional[float] = None,
    weight_kg: Optional[float] = None,
    height_ft: Optional[int] = None,
    height_in: Optional[int] = None,
    weight_lbs: Optional[float] = None,
    prior_pregnancies: int = 0,
    male_factor: bool = False,
    polycystic: bool = False,
    uterine_problems: bool = False,
    unexplained_infertility: bool = False,
    low_ovarian_reserve: bool = False,
    bmi: Optional[float] = None
) -> str:
    """
    Predict IVF success rates using SART Calculator API.

    Calculates live birth probability for 1, 2, and 3 complete IVF cycles based on patient characteristics.

    Args:
        age: Patient age in years (18-45)
        amh: Anti-MÃ¼llerian Hormone level in ng/mL
        height_cm: Height in centimeters (120-220). Use this OR height_ft/height_in
        weight_kg: Weight in kilograms (30-160). Use this OR weight_lbs
        height_ft: Height in feet (4-7). Use with height_in if not using height_cm
        height_in: Height in inches (0-11). Use with height_ft if not using height_cm
        weight_lbs: Weight in pounds (70-350). Use if not using weight_kg
        prior_pregnancies: Number of prior full-term pregnancies (>37 weeks)
        male_factor: Does partner have sperm problems?
        polycystic: Does patient have PCOS?
        uterine_problems: Does patient have uterine problems?
        unexplained_infertility: Diagnosed with unexplained infertility?
        low_ovarian_reserve: Diagnosed with low ovarian reserve?
        bmi: Body Mass Index (optional, for internal calculations)
    """
    # Build parameters for SART calculator
    calc_params = {
        "age": age,
        "amh_available": True,
        "amh_value": amh,
        "previous_full_term": prior_pregnancies > 0,
        "male_factor": male_factor,
        "polycystic": polycystic,
        "uterine_problems": uterine_problems,
        "unexplained_infertility": unexplained_infertility,
        "low_ovarian_reserve": low_ovarian_reserve,
    }

    # Add height/weight if provided
    if height_cm:
        calc_params["height_cm"] = height_cm
    if weight_kg:
        calc_params["weight_kg"] = weight_kg
    if height_ft:
        calc_params["height_ft"] = height_ft
    if height_in:
        calc_params["height_in"] = height_in
    if weight_lbs:
        calc_params["weight_lbs"] = weight_lbs

    # Calculate BMI-based weight if only BMI provided
    if bmi and not weight_kg and not weight_lbs:
        height_m = 1.65  # Assume average height
        calc_params["weight_kg"] = bmi * (height_m ** 2)

    result = await sart_ivf_server.calculate_ivf_success(**calc_params)

    # Format response
    response = {
        "tool": "predict-ivf-success",
        "patient_info": {
            "age": result["age"],
            "height_cm": result["height_cm"],
            "weight_kg": result["weight_kg"],
            "height_ft": result["height_ft"],
            "height_in": result["height_in"],
            "weight_lbs": result["weight_lbs"],
        },
        "clinical_factors": {
            "previous_full_term": result["previous_full_term"],
            "male_factor": result["male_factor"],
            "polycystic": result["polycystic"],
            "uterine_problems": result["uterine_problems"],
            "unexplained_infertility": result["unexplained_infertility"],
            "low_ovarian_reserve": result["low_ovarian_reserve"],
            "amh_value": result["amh_value"],
        },
        "success_rates": {
            "1_cycle": result["success_rate_1_cycle"],
            "2_cycles": result["success_rate_2_cycles"],
            "3_cycles": result["success_rate_3_cycles"],
        },
        "recommendations": sart_ivf_server.generate_recommendations(result),
        "data_source": "SART IVF Calculator API (University of Aberdeen)",
    }

    return json.dumps(response, indent=2)


# ==================== PubMed Tools ====================

@mcp.tool()
async def search_pubmed(query: str, max_results: int = 10) -> str:
    """
    Search PubMed for scientific articles.

    Returns a list of article PMIDs and basic information matching the search query.

    Args:
        query: Search query (e.g., 'breast cancer treatment', 'PCOS polycystic ovary syndrome')
        max_results: Maximum number of results to return (default: 10, max: 100)
    """
    max_results = min(max_results, 100)

    # Search PubMed
    search_results = await pubmed_server.search_pubmed(query, max_results)
    summaries = await pubmed_server.get_article_summaries(search_results["pmids"])

    # Format the response
    response = f"Found {search_results['count']} articles for query: '{query}'\n\n"
    response += f"Showing top {len(summaries)} results:\n\n"

    for i, summary in enumerate(summaries, 1):
        response += f"{i}. **{summary['title']}**\n"
        response += f"   - PMID: {summary['pmid']}\n"
        response += f"   - Authors: {', '.join(summary['authors'][:3])}"
        if len(summary['authors']) > 3:
            response += f" et al."
        response += f"\n   - Journal: {summary['journal']}\n"
        response += f"   - Published: {summary['pubdate']}\n"
        if summary['doi']:
            response += f"   - DOI: {summary['doi']}\n"
        response += "\n"

    response += "\nUse the 'get_article' tool with a PMID to retrieve the full abstract and details."

    return response


@mcp.tool()
async def get_article(pmid: str) -> str:
    """
    Retrieve full article details including title, abstract, authors, journal, publication date, DOI, and keywords.

    Args:
        pmid: PubMed ID (PMID) of the article to retrieve
    """
    article = await pubmed_server.fetch_article_abstract(pmid)

    # Format the response
    response = f"# {article['title']}\n\n"
    response += f"**PMID:** {article['pmid']}\n"
    if article['doi']:
        response += f"**DOI:** {article['doi']}\n"
    response += f"**Journal:** {article['journal']}\n"
    response += f"**Published:** {article['pubdate']}\n\n"

    if article['authors']:
        response += f"**Authors:** {', '.join(article['authors'])}\n\n"

    if article['keywords']:
        response += f"**Keywords:** {', '.join(article['keywords'])}\n\n"

    if article['abstract']:
        response += f"## Abstract\n\n{article['abstract']}\n"
    else:
        response += "**Note:** Abstract not available for this article.\n"

    return response


@mcp.tool()
async def get_multiple_articles(pmids: list[str]) -> str:
    """
    Retrieve full details for multiple PubMed articles at once.

    Returns abstracts, titles, authors, and metadata for all specified PMIDs.

    Args:
        pmids: List of PubMed IDs to retrieve
    """
    articles = []
    for pmid in pmids:
        article = await pubmed_server.fetch_article_abstract(pmid)
        articles.append(article)
        await asyncio.sleep(0.34)  # Rate limiting

    # Format the response
    response = f"Retrieved {len(articles)} articles:\n\n"
    response += "=" * 80 + "\n\n"

    for article in articles:
        response += f"# {article['title']}\n\n"
        response += f"**PMID:** {article['pmid']}\n"
        if article['doi']:
            response += f"**DOI:** {article['doi']}\n"
        response += f"**Journal:** {article['journal']}\n"
        response += f"**Published:** {article['pubdate']}\n\n"

        if article['authors']:
            response += f"**Authors:** {', '.join(article['authors'])}\n\n"

        if article['keywords']:
            response += f"**Keywords:** {', '.join(article['keywords'])}\n\n"

        if article['abstract']:
            response += f"## Abstract\n\n{article['abstract']}\n"
        else:
            response += "**Note:** Abstract not available for this article.\n"

        response += "\n" + "=" * 80 + "\n\n"

    return response


# ==================== ESHRE Guidelines Tools ====================

@mcp.tool()
async def list_eshre_guidelines() -> str:
    """
    List all available ESHRE clinical guidelines and recommendations.
    """
    guidelines = await eshre_server.parse_guidelines_list()

    result = "# ESHRE Clinical Guidelines\n\n"
    result += f"Found {len(guidelines)} clinical guidelines:\n\n"

    for i, guideline in enumerate(guidelines, 1):
        result += f"{i}. **{guideline['title']}**\n"
        if guideline['description']:
            result += f"   {guideline['description']}\n"
        result += f"   URL: {guideline['url']}\n\n"

    return result


@mcp.tool()
async def search_eshre_guidelines(query: str) -> str:
    """
    Search ESHRE guidelines by keyword or topic.

    Args:
        query: Search query (e.g., 'endometriosis', 'IVF', 'PCOS', 'fertility preservation')
    """
    results = await eshre_server.search_guidelines(query)

    result = f"# Search Results for '{query}'\n\n"
    result += f"Found {len(results)} matching guidelines:\n\n"

    for i, guideline in enumerate(results, 1):
        result += f"{i}. **{guideline['title']}**\n"
        if guideline['description']:
            result += f"   {guideline['description']}\n"
        result += f"   URL: {guideline['url']}\n\n"

    if not results:
        result += "No guidelines found matching your query.\n"
        result += "Try different keywords or browse all guidelines using list_eshre_guidelines.\n"

    return result


@mcp.tool()
async def get_eshre_guideline(url: str) -> str:
    """
    Retrieve the full content and download links for a specific ESHRE guideline.

    Args:
        url: Full URL of the guideline document
    """
    content = await eshre_server.get_guideline_content(url)

    result = f"# {content['title']}\n\n"
    result += f"**URL:** {content['url']}\n"
    if content['date']:
        result += f"**Published:** {content['date']}\n"
    result += f"**Word Count:** {content['word_count']}\n\n"

    if content['downloads']:
        result += "## Downloads\n\n"
        for dl in content['downloads']:
            result += f"- [{dl['title']}]({dl['url']})\n"
        result += "\n"

    result += "---\n\n"
    result += content['content']

    return result


# ==================== NAMS Tools ====================

@mcp.tool()
async def list_nams_position_statements() -> str:
    """
    List available NAMS position statements and clinical guidelines on menopause management.
    """
    statements = await nams_server.parse_position_statements()

    # Supplement with known statements if needed
    if len(statements) < 5:
        known = nams_server.get_known_position_statements()
        seen_urls = {s['url'] for s in statements}
        for stmt in known:
            if stmt['url'] not in seen_urls:
                statements.append(stmt)

    result = "# NAMS Position Statements & Clinical Guidelines\n\n"
    result += f"Found {len(statements)} position statements and guidelines:\n\n"

    for i, stmt in enumerate(statements, 1):
        result += f"{i}. **{stmt['title']}**\n"
        if stmt.get('topic'):
            result += f"   Topic: {stmt['topic']}\n"
        if stmt.get('description'):
            result += f"   {stmt['description']}\n"
        result += f"   Type: {stmt['type']}\n"
        result += f"   URL: {stmt['url']}\n\n"

    return result


@mcp.tool()
async def search_nams_protocols(query: str, topic: Optional[str] = None) -> str:
    """
    Search NAMS position statements and protocols by keyword or topic.

    Args:
        query: Search query (e.g., 'hormone therapy', 'hot flashes', 'bone health')
        topic: Optional topic filter (e.g., 'hormone therapy', 'cardiovascular', 'genitourinary')
    """
    results = await nams_server.search_protocols(query, topic)

    result = f"# Search Results for '{query}'\n\n"

    if topic:
        result += f"Topic filter: {topic}\n\n"

    result += f"Found {len(results)} matching documents:\n\n"

    for i, doc in enumerate(results, 1):
        result += f"{i}. **{doc['title']}**\n"
        result += f"   Type: {doc['type']}\n"
        if doc.get('topic'):
            result += f"   Topic: {doc['topic']}\n"
        if doc.get('description'):
            result += f"   {doc['description']}\n"
        result += f"   URL: {doc['url']}\n\n"

    if not results:
        result += "No documents found matching your query.\n"
        result += "Try different keywords or browse all documents using list_nams_position_statements.\n"
        result += "\nCommon topics: hormone therapy, vasomotor symptoms, osteoporosis, cardiovascular, genitourinary\n"

    return result


@mcp.tool()
async def get_nams_protocol(url: str) -> str:
    """
    Retrieve the full content of a specific NAMS protocol or position statement.

    Args:
        url: Full URL of the protocol or position statement
    """
    content = await nams_server.get_protocol_content(url)

    result = f"# {content['title']}\n\n"
    result += f"**URL:** {content['url']}\n"
    result += f"**Content Type:** {content['content_type']}\n"
    if content.get('date'):
        result += f"**Date:** {content['date']}\n"
    if content['word_count'] > 0:
        result += f"**Word Count:** {content['word_count']}\n"
    result += "\n---\n\n"
    result += content['content']

    return result


# ==================== ASRM Tools ====================

@mcp.tool()
async def list_asrm_practice_documents() -> str:
    """
    List available ASRM practice committee documents and guidelines.
    """
    documents = await asrm_server.parse_practice_documents()

    result = "# ASRM Practice Documents\n\n"
    result += f"Found {len(documents)} practice documents:\n\n"

    for i, doc in enumerate(documents[:15], 1):  # Limit for readability
        result += f"{i}. **{doc['title']}**\n"
        if doc['description']:
            result += f"   {doc['description']}\n"
        result += f"   URL: {doc['url']}\n\n"

    if len(documents) > 15:
        result += f"\n...and {len(documents) - 15} more documents.\n"

    return result


@mcp.tool()
async def list_asrm_ethics_opinions() -> str:
    """
    List available ASRM ethics committee opinions.
    """
    opinions = await asrm_server.parse_ethics_opinions()

    result = "# ASRM Ethics Opinions\n\n"
    result += f"Found {len(opinions)} ethics opinions:\n\n"

    for i, op in enumerate(opinions[:15], 1):
        result += f"{i}. **{op['title']}**\n"
        if op['description']:
            result += f"   {op['description']}\n"
        result += f"   URL: {op['url']}\n\n"

    if len(opinions) > 15:
        result += f"\n...and {len(opinions) - 15} more opinions.\n"

    return result


@mcp.tool()
async def search_asrm_guidelines(query: str, category: Optional[str] = None) -> str:
    """
    Search ASRM guidelines by keyword.

    Args:
        query: Search query (e.g., 'IVF', 'endometriosis', 'genetic testing')
        category: Optional category filter ('practice' or 'ethics')
    """
    results = await asrm_server.search_guidelines(query, category)

    result = f"# Search Results for '{query}'\n\n"

    if category:
        result += f"Category: {category}\n\n"

    result += f"Found {len(results)} matching documents:\n\n"

    for i, doc in enumerate(results, 1):
        result += f"{i}. **{doc['title']}**\n"
        result += f"   Type: {doc['type']}\n"
        if doc['description']:
            result += f"   {doc['description']}\n"
        result += f"   URL: {doc['url']}\n\n"

    if not results:
        result += "No documents found matching your query.\n"
        result += "Try different keywords or browse all documents using list_asrm_practice_documents or list_asrm_ethics_opinions.\n"

    return result


@mcp.tool()
async def get_asrm_guideline(url: str) -> str:
    """
    Retrieve the full content of a specific ASRM guideline document.

    Args:
        url: Full URL of the guideline document
    """
    content = await asrm_server.get_guideline_content(url)

    result = f"# {content['title']}\n\n"
    result += f"**URL:** {content['url']}\n"
    if content['date']:
        result += f"**Date:** {content['date']}\n"
    result += f"**Word Count:** {content['word_count']}\n\n"
    result += "---\n\n"
    result += content['content']

    return result


# ==================== ELSA Tools ====================

@mcp.tool()
async def list_elsa_waves(include_details: bool = False) -> str:
    """
    List all available ELSA waves with basic information.

    Args:
        include_details: Include detailed information about each wave
    """
    if include_details:
        result = {
            "study": "English Longitudinal Study of Ageing",
            "study_number": "5050",
            "total_waves": len(elsa_server.ELSA_WAVES),
            "waves": elsa_server.ELSA_WAVES
        }
    else:
        result = {
            "study": "English Longitudinal Study of Ageing",
            "total_waves": len(elsa_server.ELSA_WAVES),
            "waves": [
                {
                    "wave": v["wave"],
                    "name": v["name"],
                    "year": v["year"]
                }
                for v in elsa_server.ELSA_WAVES.values()
            ]
        }

    return json.dumps(result, indent=2)


@mcp.tool()
async def search_elsa_data(query: str, module: Optional[str] = None) -> str:
    """
    Search ELSA data modules and variables by topic or keyword.

    Args:
        query: Search term (e.g., 'cognitive', 'depression', 'wealth', 'menopause')
        module: Specific module to search (optional)
    """
    query_lower = query.lower()
    results = []

    modules_to_search = {module: elsa_server.ELSA_DATA_MODULES[module]} if module else elsa_server.ELSA_DATA_MODULES

    for mod_id, mod_data in modules_to_search.items():
        searchable_text = f"{mod_data['name']} {mod_data['description']} {' '.join(mod_data['variables'])}".lower()

        if query_lower in searchable_text:
            results.append({
                "module_id": mod_id,
                "module_name": mod_data["name"],
                "description": mod_data["description"],
                "relevant_variables": [v for v in mod_data["variables"] if query_lower in v.lower()]
            })

    return json.dumps({
        "query": query,
        "results_found": len(results),
        "modules": results
    }, indent=2)


# Run the server
if __name__ == "__main__":
    mcp.run()
